package mpc

import (
	"bytes"
	"encoding"
	"encoding/gob"
	"fmt"
	"runtime"

	"github.com/xxtea01/cb-mpc/demos-go/cb-mpc-go/api/curve"
	curveref "github.com/xxtea01/cb-mpc/demos-go/cb-mpc-go/api/internal/curveref"
	"github.com/xxtea01/cb-mpc/demos-go/cb-mpc-go/internal/cgobinding"
)

// Compile-time assertions to ensure ECDSAMPCKey implements the binary
// marshaling interfaces. These will fail to compile if the method set ever
// becomes incomplete.
var (
	_ encoding.BinaryMarshaler   = (*ECDSAMPCKey)(nil)
	_ encoding.BinaryUnmarshaler = (*ECDSAMPCKey)(nil)
)

// ECDSA N-Party (Multi-Party) API
// This API provides N-party ECDSA key generation and signing operations
// for scenarios requiring more than 2 parties (e.g., 3, 4, 5+ parties).

// ============================================================================
// Request/Response Types
// ============================================================================

// ECDSAMPCKey is an opaque handle to an N-party ECDSA key share.
//
// It mirrors the design of ECDSA2PCKey and intentionally hides the
// underlying cgobinding representation from API consumers.
//
// NOTE: the zero value is considered invalid.
type ECDSAMPCKey cgobinding.Mpc_eckey_mp_ref

// newECDSAMPCKey wraps the given cgobinding key reference in an ECDSAMPCKey
// value and installs a finalizer to automatically release native resources
// when the Go value becomes unreachable.
func newECDSAMPCKey(ref cgobinding.Mpc_eckey_mp_ref) ECDSAMPCKey {
	// We purposefully avoid installing a finalizer here. Although automatic
	// cleanup is convenient, the ECDSAMPCKey value is small (it merely wraps
	// an unsafe pointer) and is frequently copied. Go's finalizer semantics
	// make it hard to guarantee that *all* copies of the value refer to the
	// same underlying storage, which can easily lead to double-free bugs. We
	// therefore rely on callers to invoke (*ECDSAMPCKey).Free() explicitly
	// when they are done with the key share.
	return ECDSAMPCKey(ref)
}

// Free releases the underlying native key-share object. Callers who wish to
// deterministically free resources can invoke this method. If not called
// explicitly, the finalizer registered by newECDSAMPCKey will eventually take
// care of cleanup.
func (k *ECDSAMPCKey) Free() {
	if k == nil {
		return
	}
	ref := cgobinding.Mpc_eckey_mp_ref(*k)
	(&ref).Free()
	// Prevent double free by clearing the opaque pointer and disabling the
	// finalizer.
	*k = ECDSAMPCKey(cgobinding.Mpc_eckey_mp_ref{})
	runtime.SetFinalizer(k, nil)
}

// MarshalBinary serializes the receiver into a byte slice that implements
// encoding.BinaryMarshaler. The output is produced by the underlying native
// helper and subsequently gob-encoded to ensure a portable wire format. The
// representation is intended for short-term transport or caching and should
// not be relied upon for long-term persistence across cb-mpc versions.
func (k ECDSAMPCKey) MarshalBinary() ([]byte, error) {
	parts, err := cgobinding.SerializeECDSAShare(k.cgobindingRef())
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := gob.NewEncoder(&buf).Encode(parts); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// UnmarshalBinary restores the key share from the byte slice generated by
// MarshalBinary. The receiver is overwritten with the newly decoded
// ECDSAMPCKey and will point to a fresh native object. Callers that wish to
// reclaim any resources referenced by the previous value should invoke
// (*ECDSAMPCKey).Free before calling this method.
func (k *ECDSAMPCKey) UnmarshalBinary(data []byte) error {
	var parts [][]byte
	if err := gob.NewDecoder(bytes.NewReader(data)).Decode(&parts); err != nil {
		return err
	}
	keyRef, err := cgobinding.DeserializeECDSAShare(parts)
	if err != nil {
		return err
	}
	*k = newECDSAMPCKey(keyRef)
	return nil
}

// PartyName returns the string identifier of the party that owns this key
// share. It is fetched from the underlying C++ `key_share_mp_t::party_name`
// field via the cgobinding helper.
func (k ECDSAMPCKey) PartyName() (string, error) {
	return cgobinding.MPC_mpc_eckey_mp_get_party_name(cgobinding.Mpc_eckey_mp_ref(k))
}

// XShare returns the scalar secret share x_i held by this party.
func (k ECDSAMPCKey) XShare() (*curve.Scalar, error) {
	bytes, err := cgobinding.MPC_mpc_eckey_mp_get_x_share(k.cgobindingRef())
	if err != nil {
		return nil, err
	}
	return &curve.Scalar{Bytes: bytes}, nil
}

// Q returns the aggregated public key point associated with the distributed key.
// The returned Point must be freed by the caller.
func (k ECDSAMPCKey) Q() (*curve.Point, error) {
	cRef, err := cgobinding.MPC_mpc_eckey_mp_Q(k.cgobindingRef())
	if err != nil {
		return nil, err
	}
	return curveref.PointFromCRef(cRef), nil
}

// Curve returns the elliptic curve associated with this key.
// The caller is responsible for freeing the returned Curve when done.
func (k ECDSAMPCKey) Curve() (curve.Curve, error) {
	cRef, err := cgobinding.MPC_mpc_eckey_mp_curve(k.cgobindingRef())
	if err != nil {
		return nil, err
	}
	return curveref.CurveFromCRef(cRef), nil
}

// Qis returns the per-party public key shares Qi for all peers.
// The caller is responsible for freeing the individual Point values when no
// longer needed.
func (k ECDSAMPCKey) Qis() (map[string]*curve.Point, error) {
	names, points, err := cgobinding.MPC_mpc_eckey_mp_Qis(k.cgobindingRef())
	if err != nil {
		return nil, err
	}
	if len(names) != len(points) {
		return nil, fmt.Errorf("inconsistent Qis arrays: %d names vs %d points", len(names), len(points))
	}
	out := make(map[string]*curve.Point, len(names))
	for i, nameBytes := range names {
		pt, err := curve.NewPointFromBytes(points[i])
		if err != nil {
			return nil, fmt.Errorf("failed to decode Qi for party %s: %v", string(nameBytes), err)
		}
		out[string(nameBytes)] = pt
	}
	return out, nil
}

// cgobindingRef unwraps the internal cgobinding key reference. It is kept
// unexported to discourage direct use outside of this package.
func (k ECDSAMPCKey) cgobindingRef() cgobinding.Mpc_eckey_mp_ref {
	return cgobinding.Mpc_eckey_mp_ref(k)
}

// ECDSAMPCKeyGenRequest represents a request for N-party ECDSA key generation.
// The caller specifies the Curve instance instead of a raw numeric identifier
// to align the API with other MPC primitives (e.g. ECDSA2PC).
type ECDSAMPCKeyGenRequest struct {
	Curve curve.Curve // Elliptic curve to use (e.g., secp256k1)
}

// ECDSAMPCKeyGenResponse represents the response from N-party ECDSA key generation
type ECDSAMPCKeyGenResponse struct {
	KeyShare ECDSAMPCKey // The distributed key share for this party
}

// ============================================================================
// Core API Functions
// ============================================================================

// ECDSAMPCKeyGen performs N-party ECDSA distributed key generation
// All parties must call this function simultaneously with the same parameters
func ECDSAMPCKeyGen(jobmp *JobMP, req *ECDSAMPCKeyGenRequest) (*ECDSAMPCKeyGenResponse, error) {
	if jobmp == nil {
		return nil, fmt.Errorf("job must be provided")
	}
	if req == nil {
		return nil, fmt.Errorf("request cannot be nil")
	}
	if req.Curve == nil {
		return nil, fmt.Errorf("curve must be provided")
	}
	if jobmp.NParties() < 3 {
		return nil, fmt.Errorf("n-party ECDSA requires at least 3 parties (use ECDSA2PC for 2-party)")
	}

	// Perform distributed key generation using the provided JobMP and curve
	keyShare, err := cgobinding.KeyShareDKG(jobmp.cgo(), curveref.Ref(req.Curve))
	if err != nil {
		return nil, fmt.Errorf("ECDSA N-party key generation failed: %v", err)
	}

	return &ECDSAMPCKeyGenResponse{KeyShare: newECDSAMPCKey(keyShare)}, nil
}

// ECDSAMPCSignRequest represents a request for N-party ECDSA signing
type ECDSAMPCSignRequest struct {
	KeyShare          ECDSAMPCKey // The key share from key generation
	Message           []byte      // The message to sign
	SignatureReceiver int         // Which party should receive the final signature (typically 0)
}

// ECDSAMPCSignResponse represents the response from N-party ECDSA signing
type ECDSAMPCSignResponse struct {
	Signature []byte // The ECDSA signature (only populated for the designated receiver)
}

// ECDSAMPCSign performs N-party ECDSA signing
// All parties must call this function simultaneously with their respective key shares
func ECDSAMPCSign(jobmp *JobMP, req *ECDSAMPCSignRequest) (*ECDSAMPCSignResponse, error) {
	if jobmp == nil {
		return nil, fmt.Errorf("job must be provided")
	}
	if req == nil {
		return nil, fmt.Errorf("request cannot be nil")
	}
	if jobmp.NParties() < 3 {
		return nil, fmt.Errorf("n-party signing requires at least 3 parties")
	}
	if len(req.Message) == 0 {
		return nil, fmt.Errorf("message cannot be empty")
	}

	// Perform distributed signing using the provided JobMP
	signature, err := cgobinding.MPC_ecdsampc_sign(jobmp.cgo(), req.KeyShare.cgobindingRef(), req.Message, req.SignatureReceiver)
	if err != nil {
		return nil, fmt.Errorf("ECDSA N-party signing failed: %v", err)
	}

	// Determine current party index
	roleIndex := jobmp.GetPartyIndex()

	// Only the designated receiver gets the signature
	var sigBytes []byte
	if roleIndex == req.SignatureReceiver {
		sigBytes = signature
	}

	return &ECDSAMPCSignResponse{Signature: sigBytes}, nil
}

// ECDSAMPCRefreshRequest represents the parameters required to refresh (re-share)
// an existing N-party ECDSA key.
//
// The protocol produces a fresh set of secret shares such that the combined
// public key remains unchanged while each party obtains a new independent
// share.
//
// A unique SessionID must be supplied by the caller. It should be identical
// for all parties participating in the refresh procedure. If SessionID is
// nil or empty, a random identifier will be generated internally.
//
// NOTE: The refresh protocol is an N-party operation â€“ all parties that
// originally participated in key generation must invoke it concurrently.
type ECDSAMPCRefreshRequest struct {
	KeyShare  ECDSAMPCKey // Existing key share to be refreshed
	SessionID []byte      // Caller-provided session identifier (optional)
}

// ECDSAMPCRefreshResponse contains the newly generated key share that
// replaces the caller's previous share.
type ECDSAMPCRefreshResponse struct {
	NewKeyShare ECDSAMPCKey // The refreshed key share for this party
}

// ECDSAMPCRefresh executes the key-refresh protocol for an existing N-party
// ECDSA key. All parties must invoke this function concurrently with their
// current key shares and an identical SessionID.
func ECDSAMPCRefresh(jobmp *JobMP, req *ECDSAMPCRefreshRequest) (*ECDSAMPCRefreshResponse, error) {
	if jobmp == nil {
		return nil, fmt.Errorf("job must be provided")
	}
	if req == nil {
		return nil, fmt.Errorf("request cannot be nil")
	}
	if jobmp.NParties() < 3 {
		return nil, fmt.Errorf("n-party refresh requires at least 3 parties")
	}
	// Ensure a session ID is always provided to the native layer. If the caller
	// did not supply one, fall back to an empty slice (the binding will handle
	// conversion to an empty cmem_t).
	sid := req.SessionID

	newKey, err := cgobinding.KeyShareRefresh(jobmp.cgo(), sid, req.KeyShare.cgobindingRef())
	if err != nil {
		return nil, fmt.Errorf("ECDSA N-party refresh failed: %v", err)
	}

	return &ECDSAMPCRefreshResponse{NewKeyShare: newECDSAMPCKey(newKey)}, nil
}

// ECDSAMPCThresholdDKGRequest represents the input parameters for running the
// threshold Distributed Key Generation (DKG) protocol. The protocol generates
// an N-party ECDSA key that can later be used by any quorum that satisfies the
// provided access-structure policy.
//
// All parties that participate in the initial key generation (typically all
// online parties) must invoke ECDSAMPCThresholdDKG concurrently using the same
// parameters.
//
// AccessStructure describes the quorum policy that determines which subsets of
// parties are authorized to later perform signature operations. Callers should
// construct it using the high-level helpers provided in this package (see
// Leaf/And/Or/Threshold plus the AccessStructure wrapper) rather than dealing
// with low-level cgobinding functions.
type ECDSAMPCThresholdDKGRequest struct {
	Curve           curve.Curve      // Elliptic curve to use (e.g. secp256k1)
	SessionID       []byte           // Optional caller-supplied session identifier
	AccessStructure *AccessStructure // Quorum access-structure description
	QuorumRIDs      []int            // (Optional) Indices of parties that will form the quorum; defaults to all parties if nil/empty
}

// ECDSAMPCThresholdDKGResponse contains the newly generated key share owned by
// the calling party.
type ECDSAMPCThresholdDKGResponse struct {
	KeyShare ECDSAMPCKey
}

// ECDSAMPCThresholdDKG executes the threshold DKG protocol and returns the
// caller's key share. Internally it delegates to cgobinding.ThresholdDKGCurve.
//
// Usage notes:
//   - jobmp must represent *all* parties involved in the DKG.
//   - The AccessStructure parameter must describe a quorum that can be satisfied
//     by (a subset of) the parties represented by jobmp.
func ECDSAMPCThresholdDKG(jobmp *JobMP, req *ECDSAMPCThresholdDKGRequest) (*ECDSAMPCThresholdDKGResponse, error) {
	if jobmp == nil {
		return nil, fmt.Errorf("job must be provided")
	}
	if req == nil {
		return nil, fmt.Errorf("request cannot be nil")
	}
	if req.Curve == nil {
		return nil, fmt.Errorf("curve must be provided")
	}

	// Ensure a session ID is always passed to the binding. An empty slice is
	// interpreted as "let the native implementation pick a random SID".
	sid := req.SessionID

	// Ensure we have a valid access-structure description.
	if req.AccessStructure == nil {
		return nil, fmt.Errorf("access structure must be provided")
	}

	// Translate the high-level Go representation into the native C handle.
	acPtr := req.AccessStructure.toCryptoAC()

	// Determine which party indices will participate in DKG.
	roleIndices := req.QuorumRIDs
	if len(roleIndices) == 0 {
		// Fallback to all parties if caller did not supply a custom set.
		roleIndices = make([]int, jobmp.NParties())
		for i := 0; i < jobmp.NParties(); i++ {
			roleIndices[i] = i
		}
	}

	// Run the native threshold DKG using the curve reference directly to
	// avoid leaking numeric NIDs into the API layer.
	keyShareRef, err := cgobinding.ThresholdDKG(jobmp.cgo(), curveref.Ref(req.Curve), sid, acPtr, roleIndices)
	if err != nil {
		return nil, fmt.Errorf("ECDSA threshold DKG failed: %v", err)
	}

	return &ECDSAMPCThresholdDKGResponse{KeyShare: newECDSAMPCKey(keyShareRef)}, nil
}

// ToAdditiveShare converts the multiplicative secret-share representation
// embodied by the ECDSAMPCKey into an additive share that satisfies the
// provided access-structure. The resulting key share can be used by the
// threshold signing routines that expect additive shares. The aggregated
// public key is preserved by the transformation.
func (k ECDSAMPCKey) ToAdditiveShare(ac *AccessStructure, quorumPartyNames []string) (ECDSAMPCKey, error) {
	// Validate inputs
	if ac == nil {
		return ECDSAMPCKey{}, fmt.Errorf("access structure must be provided")
	}
	if len(quorumPartyNames) == 0 {
		return ECDSAMPCKey{}, fmt.Errorf("quorumPartyNames cannot be empty")
	}

	// Translate the high-level AccessStructure into the native representation.
	// The native object returned by toCryptoAC carries a finalizer that will
	// release its resources once it becomes unreachable, so we do not free
	// it explicitly here to avoid double-free errors.
	acPtr := ac.toCryptoAC()

	// Forward to the low-level helper using the underlying cgobinding key ref.
	keyRef := cgobinding.Mpc_eckey_mp_ref(k)
	additiveRef, err := (&keyRef).ToAdditiveShare(acPtr, quorumPartyNames)
	if err != nil {
		return ECDSAMPCKey{}, err
	}
	return newECDSAMPCKey(additiveRef), nil
}
