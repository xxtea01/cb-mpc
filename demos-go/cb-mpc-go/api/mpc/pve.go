package mpc

import (
	"fmt"

	"github.com/xxtea01/cb-mpc/demos-go/cb-mpc-go/api/curve"
	"github.com/xxtea01/cb-mpc/demos-go/cb-mpc-go/api/internal/curveref"
	"github.com/xxtea01/cb-mpc/demos-go/cb-mpc-go/internal/cgobinding"
)

// PVE (Publicly Verifiable Encryption) API
// This API provides secure backup and recovery functionality for cryptographic key shares
// using threshold encryption with publicly verifiable properties.

// ============================================================================
// Base Encryption Key Pair Generation
// ============================================================================

// BaseEncPrivateKey is an opaque byte slice holding a serialized `crypto::prv_key_t`.
// Callers MUST treat the contents as opaque and pass it back to library
// routines without modification.
// The exact serialization format is defined by the underlying C++ library.
// This alias provides type safety and communicates semantic meaning.
type BaseEncPrivateKey []byte

// BaseEncPublicKey is an opaque byte slice holding a serialized `crypto::pub_key_t`.
// It is the public counterpart of BaseEncPrivateKey generated by the function
// below.
type BaseEncPublicKey []byte

// PVECiphertext is an opaque byte slice holding a serialized PVE bundle returned by encryption.
// Callers must treat the contents as opaque and feed it back to decryption without modification.
type PVECiphertext []byte

// GenerateBaseEncKeypair returns a freshly generated base encryption key pair
// on the default NIST P-256 curve. Internally it leverages the existing CGO
// helper which creates ECIES key pairs using `crypto::ecc_prv_key_t` and then
// wraps the result into the generic `crypto::prv_key_t` / `crypto::pub_key_t`
// containers.
//
// The function returns the public key first, followed by the private key, and
// finally any error that occurred.
func GenerateBaseEncKeypair() (BaseEncPublicKey, BaseEncPrivateKey, error) {
	pub, prv, err := cgobinding.GenerateBaseEncKeypair()
	if err != nil {
		return nil, nil, err
	}
	return BaseEncPublicKey(pub), BaseEncPrivateKey(prv), nil
}

// ============================================================================
// Request/Response Types
// ============================================================================

// PVEEncryptRequest represents a request for PVE encryption (backup)
type PVEEncryptRequest struct {
	AccessStructure *AccessStructure            // Quorum policy & curve description
	PublicKeys      map[string]BaseEncPublicKey // Map of leaf name -> public encryption key
	Curve           curve.Curve                 // Optional override curve (nil => derive from AccessStructure or default P-256)
	PrivateValues   []*curve.Scalar             // Private data to backup (key shares)
	Label           string                      // Human-readable label bound to the backup
}

// PVEEncryptResponse represents the response from PVE encryption
type PVEEncryptResponse struct {
	EncryptedBundle PVECiphertext // The encrypted backup bundle
}

// PVEEncrypt performs publicly verifiable encryption of private shares for backup
func PVEEncrypt(req *PVEEncryptRequest) (*PVEEncryptResponse, error) {
	if req == nil {
		return nil, fmt.Errorf("request cannot be nil")
	}
	if len(req.PrivateValues) == 0 {
		return nil, fmt.Errorf("private shares cannot be empty")
	}
	if len(req.PublicKeys) == 0 {
		return nil, fmt.Errorf("public keys map cannot be empty")
	}
	if req.Label == "" {
		return nil, fmt.Errorf("label cannot be empty")
	}

	if req.AccessStructure == nil {
		return nil, fmt.Errorf("access structure cannot be nil")
	}

	// Determine the elliptic curve.
	if req.Curve == nil {
		if req.AccessStructure.Curve != nil {
			req.Curve = req.AccessStructure.Curve
		} else {
			// Fallback to NIST P-256
			p256, err := curve.NewP256()
			if err != nil {
				return nil, fmt.Errorf("failed to initialise default curve: %v", err)
			}
			req.Curve = p256
		}
	}

	curveCode := cgobinding.ECurveGetCurveCode(curveref.Ref(req.Curve))

	// Build name and key slices for CGO call
	names := make([][]byte, 0, len(req.PublicKeys))
	pubKeys := make([][]byte, 0, len(req.PublicKeys))
	for name, key := range req.PublicKeys {
		names = append(names, []byte(name))
		pubKeys = append(pubKeys, []byte(key))
	}

	// Convert PrivateShares Scalars to [][]byte for CGO.
	xs := make([][]byte, len(req.PrivateValues))
	for i, s := range req.PrivateValues {
		if s == nil {
			return nil, fmt.Errorf("private share %d is nil", i)
		}
		xs[i] = s.Bytes
	}

	// Convert the Go-level access-structure to its native representation.
	acPtr := req.AccessStructure.toCryptoAC()

	// Perform PVE encryption using cgobinding helper (AccessStructure variant).
	rawBundle, err := cgobinding.PVE_quorum_encrypt_map(
		acPtr,
		names,
		pubKeys,
		len(pubKeys),
		xs,
		len(xs),
		req.Label,
		curveCode,
	)
	if err != nil {
		return nil, fmt.Errorf("PVE encryption failed: %v", err)
	}

	return &PVEEncryptResponse{
		EncryptedBundle: PVECiphertext(rawBundle),
	}, nil
}

// PVEDecryptRequest represents a request for PVE decryption (recovery)
type PVEDecryptRequest struct {
	AccessStructure *AccessStructure             // Same access structure used for encryption
	PrivateKeys     map[string]BaseEncPrivateKey // leaf name -> private key
	PublicKeys      map[string]BaseEncPublicKey  // leaf name -> public key
	EncryptedBundle PVECiphertext                // The encrypted backup bundle
	PublicShares    []*curve.Point               // Public shares in leaf order
	Label           string                       // Label used during encryption
}

// PVEDecryptResponse represents the response from PVE decryption
type PVEDecryptResponse struct {
	PrivateValues []*curve.Scalar // The recovered private shares as Scalars
}

// PVEDecrypt performs publicly verifiable decryption to recover private shares
func PVEDecrypt(req *PVEDecryptRequest) (*PVEDecryptResponse, error) {
	if req == nil {
		return nil, fmt.Errorf("request cannot be nil")
	}
	if req.AccessStructure == nil {
		return nil, fmt.Errorf("access structure cannot be nil")
	}
	if len(req.PrivateKeys) == 0 {
		return nil, fmt.Errorf("private keys cannot be empty")
	}
	if len(req.PublicKeys) == 0 {
		return nil, fmt.Errorf("public keys cannot be empty")
	}
	if req.Label == "" {
		return nil, fmt.Errorf("label cannot be empty")
	}

	// Convert the Go-level access-structure to its native representation.
	acPtr := req.AccessStructure.toCryptoAC()

	// Determine leaf ordering from the access structure.
	leafNames := collectLeafNames(req.AccessStructure.Root)

	privBytes := make([][]byte, len(leafNames))
	pubBytes := make([][]byte, len(leafNames))
	for i, name := range leafNames {
		prv, ok1 := req.PrivateKeys[name]
		pub, ok2 := req.PublicKeys[name]
		if !ok1 || !ok2 {
			return nil, fmt.Errorf("missing keys for leaf %s", name)
		}
		privBytes[i] = []byte(prv)
		pubBytes[i] = []byte(pub)
	}

	// Serialize public shares if provided.
	xsBytes := make([][]byte, len(req.PublicShares))
	for i, pt := range req.PublicShares {
		if pt == nil {
			return nil, fmt.Errorf("public share %d is nil", i)
		}
		xsBytes[i] = pt.Bytes()
	}

	// Perform PVE decryption using cgobinding for full AccessStructure.
	recoveredShares, err := cgobinding.PVE_quorum_decrypt_map(
		acPtr,
		privBytes,
		len(privBytes),
		pubBytes,
		len(pubBytes),
		[]byte(req.EncryptedBundle),
		xsBytes,
		len(xsBytes),
		req.Label,
	)
	if err != nil {
		return nil, fmt.Errorf("PVE decryption failed: %v", err)
	}

	// The native library may return scalars with a leading padding byte.
	// Trim any excess leading bytes so that each share has exactly the byte
	// length of the curve order. This ensures round-trip consistency with the
	// input format expected by the Go layer.
	if req.AccessStructure == nil || req.AccessStructure.Curve == nil {
		return nil, fmt.Errorf("access structure or curve not set")
	}
	orderLen := len(req.AccessStructure.Curve.Order())
	scalars := make([]*curve.Scalar, len(recoveredShares))
	for i, s := range recoveredShares {
		if len(s) > orderLen {
			// Keep the least-significant bytes (big-endian encoding).
			s = s[len(s)-orderLen:]
		}
		scalars[i] = &curve.Scalar{Bytes: s}
	}

	return &PVEDecryptResponse{
		PrivateValues: scalars,
	}, nil
}

// === New Verification API ====================================================
// PVEVerifyRequest represents a request to verify a PVE bundle without revealing private keys.
type PVEVerifyRequest struct {
	AccessStructure *AccessStructure            // Same access structure used for encryption
	PublicKeys      map[string]BaseEncPublicKey // leaf name -> public key
	EncryptedBundle PVECiphertext               // The encrypted backup bundle
	PublicShares    []*curve.Point              // Public shares in leaf order
	Label           string                      // Label used during encryption
}

// PVEVerifyResponse represents the response from PVE verification.
// It wraps the boolean result indicating whether the ciphertext is valid.
type PVEVerifyResponse struct {
	Valid bool // true if the ciphertext passes verification
}

// PVEVerify checks whether the provided PVE ciphertext is valid with respect to the
// given public information (access-structure, public keys, public shares and label).
// It returns a PVEVerifyResponse containing the boolean result.
func PVEVerify(req *PVEVerifyRequest) (*PVEVerifyResponse, error) {
	if req == nil {
		return nil, fmt.Errorf("request cannot be nil")
	}
	if req.AccessStructure == nil {
		return nil, fmt.Errorf("access structure cannot be nil")
	}
	if len(req.PublicKeys) == 0 {
		return nil, fmt.Errorf("public keys cannot be empty")
	}
	if len(req.PublicShares) == 0 {
		return nil, fmt.Errorf("public shares cannot be empty")
	}
	if req.Label == "" {
		return nil, fmt.Errorf("label cannot be empty")
	}

	// Convert the Go-level access-structure to its native representation.
	acPtr := req.AccessStructure.toCryptoAC()

	// Determine leaf ordering from the access structure.
	leafNames := collectLeafNames(req.AccessStructure.Root)

	// Build name and key slices for CGO call ensuring deterministic ordering.
	names := make([][]byte, len(leafNames))
	pubBytes := make([][]byte, len(leafNames))
	for i, name := range leafNames {
		pk, ok := req.PublicKeys[name]
		if !ok {
			return nil, fmt.Errorf("missing public key for leaf %s", name)
		}
		names[i] = []byte(name)
		pubBytes[i] = []byte(pk)
	}

	// Serialize public shares if provided.
	xsBytes := make([][]byte, len(req.PublicShares))
	for i, pt := range req.PublicShares {
		if pt == nil {
			return nil, fmt.Errorf("public share %d is nil", i)
		}
		xsBytes[i] = pt.Bytes()
	}

	// Invoke native verification helper.
	err := cgobinding.PVE_quorum_verify_map(
		acPtr,
		names,
		pubBytes,
		len(pubBytes),
		[]byte(req.EncryptedBundle),
		xsBytes,
		len(xsBytes),
		req.Label,
	)
	if err != nil {
		return &PVEVerifyResponse{Valid: false}, err
	}
	return &PVEVerifyResponse{Valid: true}, nil
}

// collectLeafNames performs a DFS traversal to return leaf names in deterministic order.
func collectLeafNames(root *AccessNode) []string {
	var res []string
	var walk func(n *AccessNode)
	walk = func(n *AccessNode) {
		if n == nil {
			return
		}
		if n.Kind == KindLeaf {
			res = append(res, n.Name)
			return
		}
		for _, c := range n.Children {
			walk(c)
		}
	}
	walk(root)
	return res
}
